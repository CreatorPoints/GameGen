<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Portal The Last Dance - Photon Studios</title>
  <style>
    /* (your CSS kept exactly as before) */
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: Arial, sans-serif;
      color: white;
      background: #1b2838;
      overflow-x: hidden;
      position: relative;
    }
    #bg-video { position: fixed; top:0; left:0; width:100vw; height:100vh; object-fit:cover; z-index:-2; }
    .dark-overlay { position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.85); z-index:-1; }
    .navbar { position: fixed; top:0; width:100%; display:flex; justify-content:space-between; align-items:center; padding:15px 40px; background: rgba(0,0,0,0.7); backdrop-filter: blur(10px); z-index:100; }
    .logo { font-size:1.8rem; font-weight:bold; color:#fff; }
    .nav-links { display:flex; gap:30px; }
    .nav-links a { color:#ccc; text-decoration:none; transition:0.3s; }
    .nav-links a:hover { color:#fff; }
    #login-btn { padding:8px 15px; background:rgba(255,255,255,0.12); border:1px solid white; border-radius:6px; color:white; cursor:pointer; backdrop-filter: blur(6px); font-weight:bold; }
    #login-btn:hover { background: rgba(255,255,255,0.25); }
    .container { padding: 100px 40px 40px; }
    .game-header { text-align:center; margin-bottom:30px; }
    .game-title { font-size:2.5rem; margin-bottom:10px; }
    .game-tagline { font-size:1.2rem; color:#aaa; margin-bottom:20px; }
    .game-image-main { width:100%; max-width:800px; margin:0 auto 20px; display:block; border-radius:8px; object-fit:cover; height:400px; }
    .game-meta { display:flex; justify-content:center; gap:20px; margin-bottom:20px; flex-wrap:wrap; }
    .meta-item { background: rgba(50,60,70,0.6); padding:8px 15px; border-radius:4px; }
    .game-description { max-width:800px; margin:0 auto 30px; line-height:1.6; }
    .game-actions { text-align:center; margin-bottom:30px; }
    .btn-buy, .btn-wish { padding:12px 25px; border:none; border-radius:4px; cursor:pointer; margin:0 10px; font-size:1rem; transition:0.2s; }
    .btn-buy { background:#5aa9e6; color:white; } .btn-buy:hover { background:#4a99d6; }
    .btn-wish { background: rgba(255,255,255,0.1); color:white; border:1px solid #555; } .btn-wish:hover { background: rgba(255,255,255,0.2); }
    .btn-wish.active { background:#4caf50; }
    .like-dislike-section { text-align:center; margin:20px 0 40px; }
    .like-dislike-buttons { display:inline-flex; gap:15px; align-items:center; }
    .like-btn, .dislike-btn { background:none; border:none; color:#999; cursor:pointer; font-size:1.8rem; transition:0.2s; padding:5px; }
    .like-btn:hover, .dislike-btn:hover { color:#5aa9e6; }
    .like-btn.active { color:#4caf50; } .dislike-btn.active { color:#f44336; }
    .rating-count { font-size:1rem; color:#aaa; margin:0 10px; }
    .comments-section { max-width:800px; margin:0 auto; }
    .comments-header { margin-bottom:20px; } .comments-header h2 { display:inline-block; margin-right:15px; }
    .comments-sort { display:inline-block; }
    .comment-form { margin-bottom:30px; }
    .comment-form textarea { width:100%; padding:10px; border-radius:4px; border:1px solid #555; background: rgba(30,40,50,0.8); color:white; resize:vertical; min-height:80px; margin-bottom:10px; }
    .comment-form button { padding:10px 20px; background:#5aa9e6; color:white; border:none; border-radius:4px; cursor:pointer; } .comment-form button:hover { background:#4a99d6; }
    .comment-list { } .comment-item { padding:15px; background: rgba(30,40,50,0.6); border-radius:4px; margin-bottom:15px; }
    .comment-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
    .comment-author { font-weight:bold; color:#5aa9e6; } .comment-date { font-size:0.8rem; color:#777; } .comment-content { line-height:1.5; } .comment-actions { margin-top:8px; }
    .comment-like-btn, .comment-dislike-btn { background:none; border:none; color:#999; cursor:pointer; font-size:0.9rem; margin-right:10px; } .comment-like-btn:hover, .comment-dislike-btn:hover { color:#5aa9e6; } .comment-like-btn.active { color:#4caf50; } .comment-dislike-btn.active { color:#f44336; } .comment-rating-count { font-size:0.8rem; color:#aaa; margin-left:5px; }
    /* price display */
    .price { display:inline-block; margin-left:8px; font-weight:bold; color:#fff; background: rgba(0,0,0,0.3); padding:6px 10px; border-radius:6px; }
  </style>
</head>
<body>
  <video id="bg-video" autoplay muted loop>
    <source src="../videos/blackhole.mp4" type="video/mp4">
    Your browser does not support the video tag.
  </video>
  <div class="dark-overlay"></div>

  <div class="navbar">
    <div class="logo">PHOTON STUDIOS</div>
    <div style="display:flex;align-items:center;gap:30px;">
      <div class="nav-links">
        <a href="../index.html">Home</a>
        <a href="../photonstore.html">Shop</a>
        <a href="../photonstudio.html">News</a>
      </div>
      <button id="login-btn">Login</button>
    </div>
  </div>

  <div class="container">
    <div class="game-header">
      <h1 class="game-title">Portal: The Last Dance</h1>
      <p class="game-tagline">Corrupted core meets chaos</p>
      <img src="https://placehold.co/800x400/222222/FFFFFF?text=Portal+TLD+Hero+Image" alt="Portal: TLD Banner" class="game-image-main">
      <div class="game-meta">
        <div class="meta-item">Developer: Photon Studios</div>
        <div class="meta-item">Publisher: Photon Studios</div>
        <div class="meta-item">Release Date: 14th November 2026</div>
        <div class="meta-item">Genre: Puzzle</div>
      </div>
    </div>

    <div class="game-description">
      <p>This is a fan-made continuation to our old beloved "Portal 2" which was made by Valve Community. This game now has a new charecter (which is actually a boss), which needs to be defeated in order to complete the game. Also this game has a surprise! Play it, you'll get to know about (only if you had played Portal 2 before)</p>
      <p>Features:</p>
      <ul>
        <li>New Charecters</li>
        <li>Charecters that hid now are here</li>
        <li>Long storyline</li>
        <li>Visuals Overhauled</li>
        <li>New mechanisms</li>
      </ul>
    </div>

    <div class="game-actions">
      <button class="btn-buy" id="buy-btn">Buy ‚Äî <span id="price-el" class="price">Loading‚Ä¶</span></button>
      <button class="btn-wish" id="wish-btn">Add to Wishlist</button>
    </div>

    <div class="like-dislike-section">
      <h3>How do you feel about Portal: The Last Dance?</h3>
      <div class="like-dislike-buttons">
        <button class="like-btn" id="like-btn">üëç</button>
        <span class="rating-count" id="like-count">0</span>
        <span> / </span>
        <span class="rating-count" id="dislike-count">0</span>
        <button class="dislike-btn" id="dislike-btn">üëé</button>
      </div>
    </div>

    <div class="comments-section">
      <div class="comments-header">
        <h2>Community Reviews</h2>
        <select class="comments-sort" id="comments-sort">
          <option value="newest">Newest First</option>
          <option value="oldest">Oldest First</option>
          <option value="popular">Most Popular</option>
        </select>
      </div>

      <div class="comment-form">
        <textarea id="comment-input" placeholder="Write your review or comment..."></textarea>
        <button id="post-comment-btn">Post Comment</button>
      </div>

      <div class="comment-list" id="comment-list"></div>
    </div>
  </div>

  <script type="module">
    // ---------------------------
    // Firebase SDK imports
    // ---------------------------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
    import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
    import {
      getFirestore, doc, getDoc, setDoc, updateDoc, increment,
      query, collection, orderBy, getDocs, addDoc, deleteField,
      arrayUnion, arrayRemove, serverTimestamp, deleteDoc
    } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

    // ---------------------------
    // Config - keep your config
    // ---------------------------
    const firebaseConfig = {
      apiKey: "AIzaSyCsulwdk4ryzoCwpuKji5a8b-jXeG5ews4",
      authDomain: "photon-userbase.firebaseapp.com",
      projectId: "photon-userbase",
      storageBucket: "photon-userbase.firebasestorage.app",
      messagingSenderId: "66493624110",
      appId: "1:66493624110:web:d820995afc5b2bcad354bf",
      measurementId: "G-9RJRPKKNZV"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const provider = new GoogleAuthProvider();

    // ---------------------------
    // App state + constants
    // ---------------------------
    let currentUser = null;
    const gameId = 'portal-tld';
    const BASE_USD_PRICE = 1.90; // base price in USD

    // DOM refs (grab now; some may be updated after DOMContentLoaded)
    const loginBtn = document.getElementById('login-btn');
    const likeBtn = document.getElementById('like-btn');
    const dislikeBtn = document.getElementById('dislike-btn');
    const likeCountEl = document.getElementById('like-count');
    const dislikeCountEl = document.getElementById('dislike-count');
    const commentInput = document.getElementById('comment-input');
    const postCommentBtn = document.getElementById('post-comment-btn');
    const commentListEl = document.getElementById('comment-list');
    const commentsSortEl = document.getElementById('comments-sort');
    const buyBtn = document.getElementById('buy-btn');
    const wishBtn = document.getElementById('wish-btn');
    const priceEl = document.getElementById('price-el');

    // ---------------------------
    // Utility: ensure a document exists and has default fields if missing
    // ---------------------------
    async function ensureDoc(docRef, defaultData = {}) {
      try {
        const snap = await getDoc(docRef);
        if (!snap.exists()) {
          await setDoc(docRef, defaultData, { merge: true });
          console.log('Created missing doc:', docRef.path);
        } else {
          // ensure missing fields within existing doc are patched
          const data = snap.data();
          const update = {};
          for (const k in defaultData) {
            if (!(k in data)) update[k] = defaultData[k];
          }
          if (Object.keys(update).length) {
            await updateDoc(docRef, update);
            console.log('Patched missing fields for:', docRef.path, update);
          }
        }
      } catch (err) {
        console.error('ensureDoc error', err);
        throw err;
      }
    }

    // helper to get a docRef by path parts
    function docRefFromParts(...parts) {
      // Usage: docRefFromParts('games','portal-tld')
      if (parts.length % 2 === 0) {
        // even parts => last is doc id, so treat as doc path
        return doc(db, ...parts);
      } else {
        // odd number - last was intended as collection? fallback to doc(...)
        return doc(db, ...parts);
      }
    }

    // ---------------------------
    // Auth handling
    // ---------------------------
    onAuthStateChanged(auth, async (user) => {
      currentUser = user;
      if (user) {
        console.log('User is signed in:', user.uid);
        loginBtn.textContent = user.displayName || user.email || 'Logged In';

        // ensure user profile exists and has wishlist array
        try {
          const userRef = doc(db, 'users', user.uid);
          await ensureDoc(userRef, { wishlist: [] });
          checkWishlistStatus();
        } catch (err) {
          console.error('Failed creating/ensuring user profile', err);
          wishBtn.disabled = true;
          wishBtn.textContent = 'Error loading wishlist';
        }
      } else {
        console.log('No user signed in');
        loginBtn.textContent = 'Login';
        wishBtn.textContent = 'Add to Wishlist';
        wishBtn.classList.remove('active');
        wishBtn.disabled = false;
      }
    });

    loginBtn.addEventListener('click', () => {
      if (currentUser) {
        signOut(auth).catch(err => console.error('SignOut error', err));
      } else {
        signInWithPopup(auth, provider)
          .then(result => { currentUser = result.user; console.log('Signed in', currentUser.uid); })
          .catch(err => { console.error('SignIn error', err); alert('Login failed: ' + err.message); });
      }
    });

    // ---------------------------
    // Wishlist: check & toggle (safe)
    // ---------------------------
    async function checkWishlistStatus() {
      if (!currentUser) return;
      const userRef = doc(db, 'users', currentUser.uid);
      try {
        const snap = await getDoc(userRef);
        const data = snap.exists() ? snap.data() : {};
        const wishlist = data.wishlist || [];
        if (wishlist.includes(gameId)) {
          wishBtn.textContent = 'Remove from Wishlist';
          wishBtn.classList.add('active');
        } else {
          wishBtn.textContent = 'Add to Wishlist';
          wishBtn.classList.remove('active');
        }
      } catch (err) {
        console.error('checkWishlistStatus error', err);
        wishBtn.disabled = true;
        wishBtn.textContent = 'Error checking wishlist';
      }
    }

    async function handleWishlistToggle() {
      if (!currentUser) { alert('Please log in to manage your wishlist.'); return; }
      const userRef = doc(db, 'users', currentUser.uid);
      try {
        // ensure user doc exists
        await ensureDoc(userRef, { wishlist: [] });
        const snap = await getDoc(userRef);
        const wishlist = snap.data().wishlist || [];
        if (wishlist.includes(gameId)) {
          await updateDoc(userRef, { wishlist: arrayRemove(gameId) });
          wishBtn.textContent = 'Add to Wishlist';
          wishBtn.classList.remove('active');
        } else {
          await updateDoc(userRef, { wishlist: arrayUnion(gameId) });
          wishBtn.textContent = 'Remove from Wishlist';
          wishBtn.classList.add('active');
        }
      } catch (err) {
        console.error('Error updating wishlist:', err);
        alert('An error occurred updating your wishlist. Please try again.');
        checkWishlistStatus();
      }
    }

    // ---------------------------
    // Load / ensure game doc (likes/dislikes)
    // ---------------------------
    async function loadGameRatings() {
      const gameRef = doc(db, 'games', gameId);
      try {
        // Ensure game doc exists and has likes/dislikes fields
        await ensureDoc(gameRef, { likes: 0, dislikes: 0, title: 'Portal TLD', createdBy: 'photon' });
        const snap = await getDoc(gameRef);
        const data = snap.data();
        likeCountEl.textContent = data.likes || 0;
        dislikeCountEl.textContent = data.dislikes || 0;
      } catch (err) {
        console.error('Error loading game ratings:', err);
        likeCountEl.textContent = 'Err';
        dislikeCountEl.textContent = 'Err';
      }
    }

    // ---------------------------
    // Comments loader (safe + handles missing fields)
    // ---------------------------
    async function loadComments() {
      // Ensure the game doc is there first (this also prevents rules complaining)
      const gameRef = doc(db, 'games', gameId);
      try {
        await ensureDoc(gameRef, { likes: 0, dislikes: 0 });
      } catch (err) {
        console.error('Could not ensure game doc before loading comments', err);
      }

      const commentsRef = collection(db, 'games', gameId, 'comments');
      let q = query(commentsRef, orderBy('timestamp', 'desc'));
      const sortValue = commentsSortEl?.value || 'newest';
      if (sortValue === 'oldest') q = query(commentsRef, orderBy('timestamp', 'asc'));

      try {
        const snapshot = await getDocs(q);
        commentListEl.innerHTML = '';
        snapshot.forEach((docSnap) => {
          const data = docSnap.data();
          const commentId = docSnap.id;
          const dateText = data.timestamp ? (data.timestamp.toDate().toLocaleString()) : 'Unknown Date';
          const commentEl = document.createElement('div');
          commentEl.className = 'comment-item';
          commentEl.innerHTML = `
            <div class="comment-header">
              <div class="comment-author">${(data.userName) ? escapeHtml(data.userName) : 'Anonymous'}</div>
              <div class="comment-date">${escapeHtml(dateText)}</div>
            </div>
            <div class="comment-content">${escapeHtml(data.text || '')}</div>
            <div class="comment-actions">
              <button class="comment-like-btn" data-comment-id="${commentId}">üëç <span class="comment-rating-count">${data.likes || 0}</span></button>
              <button class="comment-dislike-btn" data-comment-id="${commentId}">üëé <span class="comment-rating-count">${data.dislikes || 0}</span></button>
            </div>
          `;
          commentListEl.appendChild(commentEl);
        });

        document.querySelectorAll('.comment-like-btn, .comment-dislike-btn').forEach(btn => {
          btn.addEventListener('click', handleCommentInteraction);
        });
      } catch (err) {
        console.error('Error loading comments:', err);
        commentListEl.innerHTML = '<p>Error loading comments.</p>';
      }
    }

    // ---------------------------
    // Post a new comment (creates required fields automatically)
    // ---------------------------
    async function handlePostComment() {
      if (!currentUser) { alert('Please log in to post a comment.'); return; }
      const text = commentInput.value.trim();
      if (!text) { alert('Please enter a comment.'); return; }

      const commentsRef = collection(db, 'games', gameId, 'comments');
      try {
        // Add with serverTimestamp so rules requiring timestamp pass
        await addDoc(commentsRef, {
          userId: currentUser.uid,
          userName: currentUser.displayName || currentUser.email || 'Anonymous User',
          text,
          timestamp: serverTimestamp(),
          likes: 0,
          dislikes: 0
        });
        commentInput.value = '';
        console.log('Comment posted by', currentUser.uid);
        await loadComments();
      } catch (err) {
        console.error('Error posting comment:', err);
        alert('An error occurred posting your comment. Please try again.');
      }
    }

    // ---------------------------
    // Comment likes/dislikes placeholder (can be expanded later)
    // ---------------------------
    async function handleCommentInteraction(e) {
      const btn = e.currentTarget;
      const commentId = btn.dataset.commentId;
      if (!currentUser) { alert('Please log in to vote on comments.'); return; }
      // For now we show a coming soon message; you can implement per-user votes by creating a subcollection or per-user doc.
      alert('Comment voting is coming soon!');
    }

    // ---------------------------
    // Like/Dislike for the game (robust + create missing docs & userInteraction)
    // ---------------------------
    async function handleLikeDislike(buttonType) {
      if (!currentUser) { alert('Please log in to like or dislike.'); return; }

      const gameRef = doc(db, 'games', gameId);
      const userInteractionRef = doc(db, 'games', gameId, 'userInteractions', currentUser.uid);

      try {
        // Ensure game doc exists with likes/dislikes
        await ensureDoc(gameRef, { likes: 0, dislikes: 0 });

        // Ensure user interaction doc exists (may be missing)
        const userSnap = await getDoc(userInteractionRef);
        const currentInteraction = userSnap.exists() ? userSnap.data().action : null;
        const newAction = (currentInteraction === buttonType) ? null : buttonType;

        // Build updates safely
        const gameUpdates = {};
        if (currentInteraction === 'like') gameUpdates.likes = increment(-1);
        if (currentInteraction === 'dislike') gameUpdates.dislikes = increment(-1);
        if (newAction === 'like') gameUpdates.likes = (gameUpdates.likes ? gameUpdates.likes : increment(0)) && increment(1);
        if (newAction === 'dislike') gameUpdates.dislikes = (gameUpdates.dislikes ? gameUpdates.dislikes : increment(0)) && increment(1);

        // Because mixing arithmetic expressions into objects can be tricky, do stepwise:
        const finalGameUpdates = {};
        if (currentInteraction === 'like') finalGameUpdates.likes = increment(-1);
        if (currentInteraction === 'dislike') finalGameUpdates.dislikes = increment(-1);
        if (newAction === 'like') finalGameUpdates.likes = (finalGameUpdates.likes ? finalGameUpdates.likes : increment(0)) , finalGameUpdates.likes = increment((finalGameUpdates.likes && 0) + 1);
        // Above line is defensive but Firestore increment takes number. Simpler approach below:

        // Simpler: compute numbers by reading current doc
        const gameSnap = await getDoc(gameRef);
        const gameData = gameSnap.exists() ? gameSnap.data() : { likes: 0, dislikes: 0 };
        let likes = gameData.likes || 0;
        let dislikes = gameData.dislikes || 0;

        if (currentInteraction === 'like') likes = Math.max(0, likes - 1);
        if (currentInteraction === 'dislike') dislikes = Math.max(0, dislikes - 1);
        if (newAction === 'like') likes = likes + 1;
        if (newAction === 'dislike') dislikes = dislikes + 1;

        // Update game doc (set new counts)
        await updateDoc(gameRef, { likes, dislikes });

        // Update or delete user interaction doc
        if (newAction) {
          await setDoc(userInteractionRef, { action: newAction }, { merge: true });
        } else {
          // remove the document if toggling off
          await deleteDoc(userInteractionRef).catch(err => {
            if (err.code !== 'not-found') throw err;
          });
        }

        // Reflect immediately in UI
        likeCountEl.textContent = likes;
        dislikeCountEl.textContent = dislikes;
        likeBtn.classList.toggle('active', newAction === 'like');
        dislikeBtn.classList.toggle('active', newAction === 'dislike');

        console.log(`User ${currentUser.uid} set action to ${newAction} for game ${gameId}`);
      } catch (err) {
        console.error('Error updating like/dislike:', err);
        alert('An error occurred. Please try again.');
        await loadGameRatings();
      }
    }

    // ---------------------------
    // Utilities: small helpers
    // ---------------------------
    function escapeHtml(str) {
      if (!str) return '';
      return String(str).replace(/[&<>"'`=\/]/g, function (s) {
        return ({
          '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;', '/': '&#x2F;', '`': '&#x60;', '=': '&#x3D;'
        })[s];
      });
    }

    // ---------------------------
    // Currency localization
    // - Detect country from locale (best-effort)
    // - Fetch rates from exchangerate.host
    // - Cache in sessionStorage (per session)
    // ---------------------------
    async function detectRegionCode() {
      try {
        const locale = Intl.DateTimeFormat().resolvedOptions().locale || navigator.language || 'en-US';
        // locale can be "en-IN" or "en-US" or "en"
        const parts = locale.split('-');
        const region = (parts.length >= 2) ? parts[1].toUpperCase() : null;
        if (region) return region;
      } catch (e) { /* fallback */ }
      // fallback: try geolocation API? we avoid permission prompts. fallback to 'US'
      return 'US';
    }

    async function fetchRates(base = 'USD') {
      const cacheKey = 'ex_rates_' + base;
      const cached = sessionStorage.getItem(cacheKey);
      if (cached) {
        try { return JSON.parse(cached); } catch (e) { /* ignore */ }
      }
      try {
        const resp = await fetch(`https://api.exchangerate.host/latest?base=${base}`);
        const data = await resp.json();
        if (data && data.rates) {
          sessionStorage.setItem(cacheKey, JSON.stringify(data));
          return data;
        }
      } catch (e) {
        console.error('fetchRates error', e);
      }
      return null;
    }

    function currencyForRegion(regionCode) {
      // minimal mapping for common countries. Expand as needed.
      const map = {
        'IN': 'INR', 'US': 'USD', 'GB': 'GBP', 'DE': 'EUR', 'FR': 'EUR',
        'JP': 'JPY', 'CN': 'CNY', 'CA': 'CAD', 'AU': 'AUD', 'SG': 'SGD',
        'BD': 'BDT', 'PK': 'PKR', 'NL': 'EUR', 'ES': 'EUR', 'IT': 'EUR'
      };
      return map[regionCode] || 'USD';
    }

    function formatCurrency(amount, currency, regionCode) {
      try {
        const locale = regionCode ? (navigator.language || 'en-US') : (navigator.language || 'en-US');
        return new Intl.NumberFormat(locale, { style: 'currency', currency }).format(amount);
      } catch (e) {
        return `${currency} ${amount.toFixed(2)}`;
      }
    }

    async function renderLocalizedPrice() {
      const region = await detectRegionCode();
      const currency = currencyForRegion(region);
      const ratesData = await fetchRates('USD'); // base USD
      let converted = BASE_USD_PRICE;
      if (ratesData && ratesData.rates && currency in ratesData.rates) {
        converted = BASE_USD_PRICE * ratesData.rates[currency];
      }
      // show converted + base
      const formatted = formatCurrency(converted, currency, region);
      priceEl.textContent = `${formatted} (USD ${BASE_USD_PRICE.toFixed(2)})`;
    }

    // ---------------------------
    // Event listeners (attach after DOM loaded)
    // ---------------------------
    document.addEventListener('DOMContentLoaded', async () => {
      // Attach listeners
      postCommentBtn.addEventListener('click', handlePostComment);
      commentsSortEl.addEventListener('change', loadComments);
      likeBtn.addEventListener('click', () => handleLikeDislike('like'));
      dislikeBtn.addEventListener('click', () => handleLikeDislike('dislike'));
      wishBtn.addEventListener('click', handleWishlistToggle);
      buyBtn.addEventListener('click', () => {
        if (!currentUser) { alert('Please log in to purchase.'); return; }
        alert('Redirecting to payment for Portal TLD (integration required)');
      });

      // Initial loads
      await renderLocalizedPrice();
      await loadGameRatings();
      await loadComments();

      // Optional: poll or set interval to refresh ratings/comments if desired
    });

    // Expose some helpers to window for debugging (optional)
    window.__photon_debug = {
      ensureDoc, loadGameRatings, loadComments, renderLocalizedPrice
    };
  </script>
</body>
</html>
